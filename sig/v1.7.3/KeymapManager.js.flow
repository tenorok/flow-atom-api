// -*- mode: javascript; -*- // @flow
/* eslint-disable no-undef */

declare interface KeyCommandMap {
  [keystroke: string]: string;
}

declare interface KeybindingsBySelector {
  [selector: string]: KeyCommandMap;
}

declare type KeydownEvent =
  | KeyboardEvent
  & { type: "keydown" }

declare class KeymapManager {
  static buildKeydownEvent(
    key: string, // FIXME: should be possible to refine this
    options?: {
      ctrl?: boolean,
      alt?: boolean,
      shift?: boolean,
      cmd?: boolean,
      which?: number, // FIXME: should be possible to refine this
      target?: Node, // FIXME
    }
  ): KeyboardEvent; // FIXME
  constructor(options: {
    defaultTarget?: Node // FIXME
  }): this;
  clear(): void;
  destroy(): void;
  onDidMatchBinding(callback: (event: {
    binding: KeyBinding,
    keystrokes: string,
    keyboardEventTarget: Node,
  }) => void): Disposable;
  onDidPartiallyMatchBindings(callback: (event: {
    keystrokes: string,
    keyboardEventTarget: Node,
    partiallyMatchedBindings: KeyBinding[],
  }) => void): Disposable;
  onDidFailToMatchBinding(callback: (event: {
    keystrokes: string,
    keyboardEventTarget: Node,
  }) => void): Disposable;
  onDidFailToReadFile(callback: (error: {
    message: string,
    stack: string,
  }) => void): Disposable;
  add(
    source: string,
    bindings: KeybindingsBySelector,
    priority: number
  ): void; // FIXME
  getKeyBindings(): KeyBinding[];
  findKeyBindings(params: {
    keystrokes?: string,
    command?: string,
    target?: Node, // FIXME
  }): KeyBinding[];
  loadKeymap(path: string, options: {
    watch?: boolean,
    priority?: number,
  }): void;
  watchKeymap(path: string, options: {
    priority?: number,
  }): void;
  handleKeyboadEvent(event: KeydownEvent): void;
  keystrokeForKeyboardEvent(event: KeydownEvent): string;
  getPartialMatchTimeout(): number;
}
