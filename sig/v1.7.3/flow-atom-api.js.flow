// -*- mode: javascript -*-
// @flow
/* eslint-disable no-undef */
declare class AtomEnvironment {
  // properties
  clipboard: Clipboard;
  commands: CommandRegistry;
  config: Config;
  contextMenu: ContextMenuManager;
  deserializers: DeserializerManager;
  grammars: GrammarRegistry;
  keymaps: KeymapManager;
  menu: MenuManager;
  notifications: NotificationManager;
  packages: PackageManager;
  project: Project;
  styles: StyleManager;
  textEditors: TextEditorRegistry;
  themes: ThemeManager;
  tooltips: TooltipManager;
  views: ViewRegistry;
  workspace: Workspace;

  // event subscription
  onDidBeep(callback: () => void): Disposable;
  onDidThrowError(
    callback:
      (event: {
        originalError: Object,
        message: string,
        url: string,
        line: number,
        column: number,
      })
      => void
  ): Disposable;
  onWillThrowError(
    callback:
      (event: {
        originalError: Object,
        message: string,
        url: string,
        line: number,
        column: number,
        preventDefault(): void,
      })
      => void
  ): Disposable;

  // atom details
  getLoadSettings(): Object;
  getVersion(): string;
  getWindowLoadTime(): number;
  inDevMode(): boolean;
  inSafeMode(): boolean;
  inSpecMode(): boolean;
  isReleasedVersion(): boolean;

  // managing the atom window
  close(): void;
  getPosition(): { x: number, y: number };
  getSize(): { width: number, height: number };
  open(
    params: {
      pathsToOpen: string[],
      newWindow: boolean,
      devMode: boolean,
      safeMode: boolean,
    }
  ): void;
  setPosition(x: number, y: number): void;
  setSize(width: number, height: number): void;

  // managing the atom window -- extended methods
  pickFolder(callback: (paths: ?(string[])) => void): void;
  getCurrentWindow(): Window;
  center(): void;
  focus(): void;
  show(): void;
  hide(): void;
  reload(): void;
  isMaximized(): boolean;
  isFullScreen(): boolean;
  setFullScreen(): void;
  toggleFullScreen(): void;

  // messaging the user
  beep(): void;
  confirm(
    options: {
      message: string,
      detailedMessage?: string,
      buttons?: string[] | { [buttonName: string]: () => void },
    }): ?number;

  // managing the dev tools
  executeJavaScriptInDevTools(code: string): void;
  openDevTools(): Promise<void>;
  toggleDevTools(): Promise<void>;
}

declare class BufferedNodeProcess {
}

declare class BufferedProcess {
}

declare class Clipboard {
}

declare class Color {
  static parse(
    value: {
      red: number,
      green: number,
      blue: number,
      alpha: number,
    }
  ): this;
  toHexString(): string;
  toRGBAString(): string;
}

declare class CommandRegistry {
  add(
    target: string,
    commandNameOrMap:
      string
      | { [commandName: string]: (event: Event) => void },
    callback?: (event: Event) => void,
  ): ?Disposable;
  dispatch(target: any, commandName: string): void;
  findCommands(params: { target: any }):
    Array<{
      name: string,
      displayName: string,
    }>;
  onDidDispatch(callback: (event: Event) => void): void;
  onWillDispatch(callback: (event: Event) => void): void;
}

declare class CompositeDisposable {
  // FIXME: docs missing args
  constructor(...disposables: Disposable[]): this;
  add(...disposables: Disposable[]): void;
  clear(): void;
  dispose(): void;
  remove(disposable: Disposable): void;
}

declare class Config {
  get(
    keyPath: string,
    options?: {
      sources?: string[],
      excludeSources?: string[],
      scope?: ScopeDescriptor,
    },
  ): any;
  getAll(
    keyPath: string,
    options: {
      sources?: string[],
      excludeSources?: string[],
      scope?: ScopeDescriptor,
    }): Array<{
      scopeDescriptor: ScopeDescriptor,
      value: any,
    }>;
  getSources(): string[];
  getSchema(keyPath: string): ?Object; // does this conform to some spec?
  getUserConfigPath(): string;
  observe(
    keyPath: string,
    options?: {
      scope?: ScopeDescriptor,
    },
    callback: (value: any) => void,
  ): Disposable;
  onDidChange(
    keyPath?: string,
    options?: {
      scope?: ScopeDescriptor,
    },
    callback:
      (event: {
        newValue: any,
        oldValue: any,
      })
      => void,
  ): Disposable;
  set(
    keyPath: string,
    value: any,
    options?: {
      scopeSelector?: string,
      source?: string,
    },
  ): boolean;
  unset(
    keyPath: string,
    options?: {
      scopeSelector?: string,
      source?: string,
    },
  ): void;
  transact(callback: () => void): void;
}

declare class ContextMenuManager {
}

declare class Cursor {
}

declare class Decoration {
  destroy(): void;
  onDidChangeProperties(
    callback:
      (event: {
        oldProperties: Object,
        newProperties: Object,
      })
      => void
  ): Disposable;
  onDidDestroy(callback: () => void): Disposable;
  // FIXME: docs unclear on return type
  getId(): number;
  // FIXME: docs unclear on return type
  getMarker(): TextEditorMarker;
  // FIXME: docs unclear on return type
  getProperties(): Object;
  setProperties(newProperties: Object): void;
}

declare type DecorationType =
  | "block"
  | "gutter"
  | "highlight"
  | "line-number"
  | "line"
  | "overlay"

declare type DecorationProperties =
  | { type: "block"
    , class: string
    , item: HTMLElement | Object
    , position: "before" | "after"
    }
  | { type: "gutter"
    , class: string
    , item: HTMLElement | Object
    , onlyEmpty?: boolean
    , onlyNonEmpty?: boolean
    }
  | { type: "highlight"
    , class: string
    , item: HTMLElement | Object
    }
  | { type: "line" | "line-number"
    , class: string
    , item: HTMLElement | Object
    , onlyHead?: boolean
    , onlyEmpty?: boolean
    , onlyNonEmpty?: boolean
    }
  | { type: "overlay"
    , class: string
    , item: HTMLElement | Object
    , position?: "head" | "tail"
    }

declare class DeserializerManager {
}

declare class Directory {
}

declare class Disposable {
  static isDisposable(object: Object): boolean;
  constructor(dispoalAction: () => void): this;
  dispose(): void;
}

declare class Emitter {
  constructor(): this;
  clear(): void;
  dispose(): void;
  on(
    eventName: string,
    handler: () => void,
  ): Disposable;
  preempt(
    eventName: string,
    handler: () => void,
  ): Disposable;
  // FIXME: docs unclear on argument types
  emit(
    eventName: string,
    value: any,
  ): void;
}

declare class File {
}

declare class GitRepository {
}

declare class Grammar {
}

declare class GrammarRegistry {
}

declare class Gutter {
}

declare class KeymapManager {
}

declare type LayerDecorationType =
  | "block"
  | "highlight"
  | "line-number"
  | "line"

declare type LayerDecorationProperties =
  | DecorationProperties & { type: LayerDecorationType }

declare class LayerDecoration {
  destroy(): void;
  isDestroyed(): boolean;
  // FIXME: docs unclear on return type
  getProperties(): LayerDecorationProperties;
  setProperties(newProperties: LayerDecorationProperties): void;
  setPropertiesForMarker(
    marker: TextEditorMarker,
    properties: Object
  ): void;
}

declare class MarkerLayer {
}

declare class MenuManager {
}

declare class Notification {
}

declare class NotificationManager {
}

declare class Package {
}

declare class PackageManager {
}

declare class Pane {
}

declare class Panel {
}

declare class Point {
}

declare class Project {
}

declare class Range {
}

declare class ScopeDescriptor {
}

declare class Selector {
}

declare class StyleManager {
}

declare class Task {
}

declare class TextBuffer {
}

declare class TextEditor {
}

declare class TextEditorMarker {
}

declare class TextEditorMarkerLayer {
}

declare class TextEditorRegistry {
}

declare class ThemeManager {
}

declare class TooltipManager {
}

declare class ViewRegistry {
}

declare class Window {
}

declare class Workspace {
}

declare var atom: AtomEnvironment;
