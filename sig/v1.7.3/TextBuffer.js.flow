// -*- mode: javascript; -*- // @flow
/* eslint-disable no-undef */

declare class TextBuffer {
  constructor(params: string | {
    load?: boolean,
    text?: string,
  }): this;
  addMarkerLayer(options?: {
    maintainHistory?: boolean,
  }): MarkerLayer;
  append(text: string, options?: {
    normalizeLineEndings?: boolean,
    undo?: "skip" | string,
  }): Range;
  backwardsScan(
    regex: RegExp,
    iterator: (event: {
      match: number, // FIXME
      matchText: string,
      range: Range, // FIXME
      stop(): void,
      replace(newText: string): void,
    }) => void, // FIXME
  ): void;
  backwardsScanInRange(
    regex: RegExp,
    range: RangeLike, // FIXME
    iterator: (event: {
      match: number, // FIXME
      matchText: string,
      range: Range, // FIXME
      stop(): void,
      replace(newText: string): void,
    }) => void, // FIXME
  ): void;
  characterIndexForPosition(position: PointLike): number;
  clearUndoStack(): void;
  clipPosition(position: PointLike): Point;
  clipRange(range: RangeLike): Range;
  createCheckpoint(): number;
  delete(range: RangeLike): Range;
  deleteRow(row: number): Range;
  deleteRows(startRow: number, endRow: number): Range;
  findMarkers(params: FindMarkersOptions): TextEditorMarker[];
  getChangesSinceCheckpoint(checkpoint: number): Array<{
    start: Point,
    oldExtent: Point,
    newExtent: Point,
    newText: string,
  }>;
  getDefaultMarkerLayer(): MarkerLayer;
  getEncoding(): string; // FIXME: should refine
  getEndPosition(): Point;
  getFirstPosition(): Point & { column: 0, row: 0 };
  getLastLine(): string;
  getLastRow(): number;
  getLineCount(): number;
  getLines(): string[];
  getMarker(id: number): TextEditorMarker;
  getMarkerCount(): number;
  getMarkerLayer(id: number): MarkerLayer;
  getMarkers(): TextEditorMarker[];
  getMaxCharacterIndex(): number;
  getPath(): string;
  getRange(): Range;
  getStoppedChangingDelay(): number;
  getText(): string;
  getTextInRange(range: RangeLike): string;
  getUri(): string;
  groupChangesSinceCheckpoint(): boolean;
  insert(
    position: PointLike,
    text: string,
    options?: {
      normalizeLineEndings?: boolean,
      undo?: "skip" | string,
    },
  ): Range;
  isEmpty(): boolean;
  isInConflict(): boolean;
  isModified(): boolean;
  isRowBlank(row: number): boolean;
  lineEndingForRow(row: number): string;
  lineForRow(row: number): string;
  lineLengthForRow(row: number): number;
  markPosition(
    position: PointLike,
    properties: MarkOptions,
  ): TextEditorMarker;
  markRange(
    range: RangeLike,
    properties: MarkOptions,
  ): TextEditorMarker;
  nextNonBlankRow(startRow: number): null | number;
  onDidChange(callback: (event: {
    newRange: Range,
    newText: string,
    oldRange: Range,
    oldText: string,
  }) => void): Disposable;
  onDidChangeEncoding(callback: (encoding: string) => void): Disposable;
  onDidChangeModified(callback: (modified: boolean) => void): Disposable;
  onDidChangePath(callback: (path: string) => void): Disposable;
  onDidConflict(callback: () => void): Disposable;
  onDidCreateMarker(callback: (marker: TextEditorMarker) => void): Disposable;
  onDidDelete(callback: () => void): Disposable;
  onDidDestroy(callback: () => void): Disposable;
  onDidReload(callback: () => void): Disposable;
  onDidSave(callback: (event: {
    path: string,
  }) => void): Disposable;
  onDidStopChanging(callback: () => void): Disposable;
  onDidUpdateMarkers(callback: () => void): Disposable;
  onWillChange(callback: (event : {
    newRange: Range,
    newText: string,
    oldRange: Range,
    oldText: string,
  }) => void): Disposable;
  onWillReload(callback: () => void): Disposable;
  onWillSave(callback: () => void): Disposable;
  onWillThrowWatchError(callback: (errorObject: {
    error: Error, // FIXME: should refine this
    handle(): void,
  }) => void): Disposable;
  positionForCharacterIndex(offset: number): Point;
  previousNonBlankRow(startRow: number): null | number;
  rangeForRow(row: number, includeNewLine: boolean): Range;
  redo(): boolean;
  reload(): void;
  replace(regex: RegExp, replacementText: string): number;
  revertToCheckpoint(): boolean;
  save(): void;
  saveAs(filePath: string): void;
  scan(
    regex: RegExp,
    iterator: (event: {
      match: number, // FIXME
      matchText: string,
      range: Range, // FIXME
      stop(): void,
      replace(newText: string): void,
    }) => void,
  ): void;
  scanInRange(
    regex: RegExp,
    range: Range, // FIXME
    iterator: (event: {
      match: number, // FIXME
      matchText: string,
      range: Range, // FIXME
      stop(): void,
      replace(newText: string): void,
    }) => void,
  ): void;
  setEncoding(encoding: string): void; // FIXME: should refine
  setPath(filePath: string): void;
  setText(text: string): Range;
  setTextInRange(
    range: RangeLike,
    text: string,
    options?: {
      normalizeLineEndings?: boolean,
      undo?: "skip" | string,
    },
  ): Range;
  setTextViaDiff(text: string): void;
  transact<T>(groupingInterval?: number, fn: () => T): void | T;
  undo(): boolean;
}
