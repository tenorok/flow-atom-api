// -*- mode: javascript; -*- // @flow
/* eslint-disable no-undef */

// FIXME: check optional fields

declare class TextEditor {
  abortTransaction(): void;
  addCursorAtBufferPosition(bufferPosition: PointLike): Cursor;
  addCursorAtScreenPosition(screenPosition: PointLike): Cursor;
  addGutter(options: {
    name: string,
    priority?: number,
    visible?: boolean
  }): Gutter;
  addMarkerLayer(options: {
    maintainHistory?: boolean,
  }): TextEditorMarkerLayer;
  addSelectionForBufferRange(
    bufferRange: RangeLike,
    options?: {
      reversed: boolean,
    }
  ): Selection;
  addSelectionForScreenRange(
    screenRange: RangeLike,
    options?: {
      reversed: boolean,
    }
  ): Selection;
  autoIndentSelectedRows(): void;
  backspace(): void;
  backwardsScanInBufferRange(
    regex: RegExp,
    range: RangeLike,
    iterator: (event: {
      match: RegExp,
      matchText: string,
      range: Range,
      stop(): void,
      replace(newText: string): void,
    }) => void, // FIXME
  ): void;
  bufferPositionForScreenPosition(
    bufferPosition: PointLike, // FIXME
    options?: {
      screenLine: boolean,
      skipSoftWrapIndentation: boolean, // FIXME: not in docs
      wrapAtSoftNewlines: boolean,
      wrapBeyondNewlines: boolean,
    },
  ): Point;
  bufferRangeForScopeAtCursor(scopeSelector: string): Range;
  bufferRangeForScreenRange(screenRange: RangeLike): Range;
  clipBufferPosition(bufferPosition: PointLike): Point;
  clipBufferRange(range: RangeLike): Range;
  clipScreenPosition(
    screenPosition: PointLike,
    options?: {
      screenLine: boolean,
      skipSoftWrapIndentation: boolean, // FIXME: not in docs
      wrapAtSoftNewlines: boolean,
      wrapBeyondNewlines: boolean,
    },
  ): Point;
  clipScreenRange(
    range: RangeLike,
    options?: {
      screenLine: boolean,
      skipSoftWrapIndentation: boolean, // FIXME: not in docs
      wrapAtSoftNewlines: boolean,
      wrapBeyondNewlines: boolean,
    },
  ): Range;
  copySelectedText(): void;
  createCheckpoint(): number;
  cutSelectedText(): void;
  cutToEndOfBufferLine(): void;
  cutToEndOfLine(): void;
  decorateMarker(
    marker: TextEditorMarker,
    decorationParams: DecorationProperties,
  ): Decoration;
  decorateMarkerLayer(
    markerLayer: TextEditorMarkerLayer,
    decorationParams: DecorationProperties,
  ): LayerDecoration;
  delete(): void;
  deleteLine(): void;
  deleteToBeginningOfLine(): void;
  deleteToBeginningOfSubword(): void;
  deleteToBeginningOfWord(): void;
  deleteToEndOfLine(): void;
  deleteToEndOfSubword(): void;
  deleteToEndOfWord(): void;
  deleteToNextWordBoundary(): void;
  deleteToPreviousWordBoundary(): void;
  findMarkers(properties: {
    startBufferRow: number,
    endBufferRow: number,
    containsBufferRange: RangeLike,
    containsBufferPosition: PointLike,
  }): TextEditorMarker[];
  foldAll(): void;
  foldAllAtIndentLevel(level: number): void;
  foldBufferRow(bufferRow: number): void;
  foldCurrentRow(): void;
  foldSelectedLines(): void;
  getBuffer(): TextBuffer;
  getCurrentParagraphBufferRange(): Range;
  getCursorAtScreenPosition(position: PointLike): void | Cursor;
  getCursorBufferPosition(): Point;
  getCursorBufferPositions(): Point[];
  getCursors(): Cursor[]; // FIXME
  getCursorScreenPosition(): Point;
  getCursorScreenPositions(): Point[];
  getCursorsOrderedByBufferPosition(): Cursor[];
  getDecorations<T: $Shape<DecorationProperties>>(propertyFilter?: T): Array<Decoration & {
    getProperties(): DecorationProperties & T,
  }>;
  getDefaultMarkerLayer(): TextEditorMarkerLayer;
  getEncoding(): FileEncoding;
  getGrammar(): Grammar;
  getGutters(): Gutter[];
  getHighlightDecorations(
    propertyFilter?: $Shape<HighlightDecorationProperties>,
  ): HighlightDecoration[];
  getLastBufferRow(): number;
  getLastCursor(): Cursor;
  getLastScreenRow(): number;
  getLastSelection(): Selection;
  getLineCount(): number;
  getLineDecorations(
    propertyFilter?: $Shape<LineDecorationProperties>,
  ): LineDecorationProperties[];
  getLineNumberDecorations(
    propertyFilter?: $Shape<LineNumberDecorationProperties>,
  ): LineNumberDecorationProperties[];
  getLongTitle(): string;
  getMarker(id: number): TextEditorMarker;
  getMarkerCount(): number;
  getMarkerLayer(id: number): MarkerLayer;
  getMarkers(): TextEditorMarker[];
  getOverlayDecorations(
    propertyFilter?: $Shape<OverlayDecorationProperties>,
  ): OverlayDecorationProperties[];
  getPath(): string;
  getPlaceholderText(): string;
  getRootScopeDescriptor(): ScopeDescriptor;
  getScreenLineCount(): number;
  getSelectedBufferRange(): Range;
  getSelectedBufferRanges(): Range[];
  getSelectedScreenRange(): Range;
  getSelectedScreenRanges(): Range[];
  getSelectedText(): string;
  getSelections(): Selection[];
  getSelectionsOrderedByBufferPosition(): Selection[];
  getSoftTabs(): boolean;
  getSoftWrapColumn(): number;
  getTabLength(): number;
  getTabText(): string;
  getText(): string;
  getTextInBufferRange(range: RangeLike): string;
  getTitle(): string;
  getWordUnderCursor(options?: { // FIXME
    allowPrevious: boolean,
    includeNonWordCharacters: boolean,
    wordRegex: RegExp,
  }): string;
  groupChangesSinceCheckpoint(checkpoint: number): boolean;
  gutterWithName(name: string): null | Gutter;
  hasMultipleCursors(): boolean;
  indentationForBufferRow(row: number): number;
  indentLevelForLine(line: string): number;
  indentSelectedRows(): void[];
  insertNewline(): false | Range;
  insertNewlineAbove(): void | Range;
  insertNewlineBelow(): false | Range;
  insertText(
    text: string,
    options?: {
      select?: boolean,
      autoIndent?: boolean,
      autoIndentNewline?: boolean,
      autoDecreaseIndent?: boolean,
      normalizeEndings?: boolean,
      undo?: "skip" | string,
    },
  ): false | Range[];
  isBufferRowCommented(): boolean;
  isEmpty(): boolean;
  isFoldableAtBufferRow(row: number): boolean;
  isFoldableAtScreenRow(row: number): boolean;
  isFoldedAtBufferRow(row: number): boolean;
  isFoldedAtCursorRow(): boolean;
  isFoldedAtScreenRow(row: number): boolean;
  isModified(): boolean;
  isSoftWrapped(): boolean;
  lineTextForBufferRow(row: number): string;
  lineTextForScreenRow(row: number): string;
  lowerCase(): mixed[]; // FIXME: docs are wrong; also, seems to return false[]
  markBufferPosition(position: PointLike, options?: MarkOptions): TextEditorMarker;
  markBufferRange(range: RangeLike, properties: MarkOptionsWithHistory): TextEditorMarker;
  markScreenPosition(position: PointLike, options?: MarkOptions): TextEditorMarker;
  markScreenRange(range: RangeLike, properties: MarkOptionsWithHistory): TextEditorMarker;
  moveToBeginningOfPreviousParagraph(): void;
  moveDown(lines?: number): void;
  moveLeft(columns?: number): void;
  moveRight(columns?: number): void;
  moveToBeginningOfLine(): void;
  moveToBeginningOfNextParagraph(): void;
  moveToBeginningOfNextWord(): void;
  moveToBeginningOfScreenLine(): void;
  moveToBeginningOfWord(): void;
  moveToBottom(): void;
  moveToEndOfLine(): void;
  moveToEndOfScreenLine(): void;
  moveToEndOfWord(): void;
  moveToFirstCharacterOfLine(): void;
  moveToNextSubwordBoundary(): void;
  moveToNextWordBoundary(): void;
  moveToPreviousSubwordBoundary(): void;
  movetoPreviousWordBoundary(): void;
  moveToTop(): void;
  moveUp(lines?: number): void;
  mutateSelectedText<T>(
    fn: (selection: Selection, index: number) => T,
    groupingInterval?: number,
  ): T[];
  observeCursors(callback: (cursor: Cursor) => void): Disposable;
  observeDecorations(callback: (decoration: Decoration) => void): Disposable;
  observeGrammar(callback: (grammar: Grammar) => void): Disposable;
  observeGutters(callback: (gutter: Gutter) => void): Disposable;
  observeSelections(callback: (selection: Selection) => void): Disposable;
  onDidAddCursor(callback: (cursor: Cursor) => void): Disposable;
  onDidAddDecoration(callback: (decoration: Decoration) => void): Disposable;
  onDidAddGutter(callback: (gutter: Gutter) => void): Disposable;
  onDidAddSelection(callback: (selection: Selection) => void): Disposable;
  onDidChange(callback: () => void): Disposable;
  onDidChangeCursorPosition(callback: (event: {
    cursor: Cursor,
    newBufferPosition: Point,
    newScreenPosition: Point,
    oldBufferPosition: Point,
    oldScreenPosition: Point,
    textChanged: boolean,
  }) => void): Disposable;
  // FIXME: docs don't mention callback args
  onDidChangeEncoding(callback: (encoding: FileEncoding) => void): Disposable;
  onDidChangeGrammar(callback: (grammar: Grammar) => void): Disposable;
  onDidChangeModified(callback: () => void): Disposable; // FIXME: callback args
  onDidChangePath(callback: () => void): Disposable; // FIXME: callback args
  onDidChangePlaceholderText(callback: (text: string) => void): Disposable;
  onDidChangeSelectionRange(callback: (event: {
    newBufferRange: Range,
    newScreenRange: Range,
    oldBufferRange: Range,
    oldScreenRange: Range,
    selection: Selection,
  }) => void): Disposable;
  onDidChangeSoftWrapped(callback: () => void): Disposable; // FIXME: callback args
  onDidChangeTitle(callback: () => void): Disposable; // FIXME: callback args
  onDidConflict(callback: () => void): Disposable; // FIXME: callback args
  onDidDestroy(callback: () => void): Disposable;
  onDidInsertText(callback: (event: {
    text: string,
  }) => void): Disposable;
  onDidRemoveCursor(callback: (cursor: Cursor) => void): Disposable;
  onDidRemoveDecoration(callback: (decoration: Decoration) => void): Disposable;
  onDidRemoveGutter(callback: (gutterName: string) => void): Disposable;
  onDidRemoveSelection(callback: (selection: Selection) => void): Disposable;
  onDidSave(callback: (event: {
    path: string,
  }) => void): Disposable;
  onDidStopChanging(callback: () => void): Disposable;
  onWillInsertText(callback: (event: {
    cancel(): void,
    text: string,
  }) => void): Disposable;
  outdentSelectedRows(): void[];
  pasteText(options?: { // FIXME: optional fields
    select?: boolean,
    autoIndent?: boolean,
    autoIndentNewline?: boolean,
    autoDecreaseIndent?: boolean,
    normalizeEndings?: boolean,
    undo?: "skip" | string,
  }): false | void[]; // FIXME
  redo(): void;
  revertToCheckpoint(): boolean;
  save(): void;
  saveAs(filePath: string): void;
  scan(
    regex: RegExp,
    iterator: (event: {
      match: number, // FIXME
      matchText: string,
      range: Range, // FIXME
      stop(): void,
      replace(newText: string): void,
    }) => void,
  ): void;
  scanInBufferRange(
    regex: RegExp,
    range: Range,
    iterator: (event: {
      match: number, // FIXME
      matchText: string,
      range: Range, // FIXME
      stop(): void,
      replace(newText: string): void,
    }) => void,
  ): void;
  scopeDescriptorForBufferPosition(position: PointLike): ScopeDescriptor;
  screenPositionForBufferPosition(
    position: PointLike,
    options?: {
      screenLine: boolean,
      skipSoftWrapIndentation: boolean, // FIXME: not in docs
      wrapAtSoftNewlines: boolean,
      wrapBeyondNewlines: boolean,
    },
  ): Point;
  screenRangeForBufferRange(range: Range): Range;
  scrollToBufferPosition(
    position: PointLike,
    options?: {
      center: boolean,
    },
  ): void;
  scrollToCursorPosition(options?: {
    center: boolean,
  }): void;
  scrollToScreenPosition(
    position: PointLike,
    options?: {
      center: boolean,
    },
  ): void;
  selectAll(): void;
  selectDown(rows?: number): void;
  selectionIntersectsBufferRange(bufferRange: RangeLike): boolean;
  selectLeft(columns?: number): void;
  selectLinesContainingCursors(): void;
  selectMarker(marker: TextEditorMarker): void | Range;
  selectRight(columns?: number): void;
  selectToBeginningOfLine(): void;
  selectToBeginningOfNextParagraph(): void;
  selectToBeginningOfNextWord(): void;
  selectToBeginningOfPreviousParagraph(): void;
  selectToBeginningOfWord(): void;
  selectToBottom(): void;
  selectToBufferPosition(position: PointLike): void;
  selectToEndOfLine(): void;
  selectToEndOfWord(): void;
  selectToFirstCharacterOfLine(): void;
  selectToNextSubwordBoundary(): void;
  selectToNextWordBoundary(): void;
  selectToPreviousSubwordBoundary(): void;
  selectToPreviousWordBoundary(): void;
  selectToScreenPosition(position: PointLike): void;
  selectToTop(): void;
  selectUp(rows?: number): void;
  selectWordsContainingCursors(): void;
  setCursorBufferPosition(
    position: PointLike,
    options?: {
      autoscroll: boolean,
      screenLine: boolean,
      wrapAtSoftNewlines: boolean,
      wrapBeyondNewlines: boolean,
    },
  ): void;
  setCursorScreenPosition(
    position: PointLike,
    options?: {
      autoscroll: boolean,
      screenLine: boolean,
      skipSoftWrapIndentation: boolean, // FIXME: not in docs
      wrapAtSoftNewlines: boolean,
      wrapBeyondNewlines: boolean,
    },
  ): void;
  setEncoding(encoding: FileEncoding): void;
  setGrammar(grammar: Grammar): void;
  setIndentationForBufferRow(
    bufferRow: number,
    newLevel: number,
    options?: {
      preserveLeadingWhitespace?: boolean,
    },
  ): void;
  setPlaceholderText(placeholderText: string): void;
  setSelectedBufferRange(
    bufferRange: RangeLike,
    options?: {
      reversed?: boolean,
      preserveFolds?: boolean,
    },
  ): void;
  setSelectedBufferRanges(
    bufferRanges: RangeLike[],
    options?: { // FIXME: are these optional?
      reversed?: boolean,
      preserveFolds?: boolean,
    },
  ): void;
  setSelectedScreenRange(
    screenRange: RangeLike,
    options?: {
      reversed?: boolean,
    },
  ): void;
  setSelectedScreenRanges(
    screenRanges: RangeLike[],
    options?: {
      reversed?: boolean,
    },
  ): void;
  setSoftTabs(softTabs: boolean): void;
  setSoftWrapped(softWrapped: boolean): boolean;
  setTabLength(tabLength: null | number): void;
  setText(text: string): void;
  setTextInBufferRange(
    range: RangeLike,
    text: String,
    options?: {
      normalizeLineEndings?: boolean,
      undo?: string,
    },
  ): Range;
  toggleFoldAtBufferRow(): void;
  toggleLineCommentsInSelection(): void;
  toggleSoftTabs(): void;
  toggleSoftWrapped(): boolean;
  transact<T>(groupingInterval?: number, fn: () => T): void | T;
  transpose(): void;
  undo(): void;
  unfoldAll(): void;
  unfoldBufferRow(bufferRow: number): void;
  unfoldCurrentRow(): void;
  upperCase(): void;
  usesSoftTabs(): boolean;
}
